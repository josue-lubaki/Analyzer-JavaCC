
/*
danson@grafidog.com: Modified to support Java 7:
- binary literals
- underscores in numeric literals
- strings in switch statements (no change needed)
- type inference for generic instance creation (no changes needed)
- improved compiler warnings and errors when using non-reifiable formal parameters with varargs methods (no changes needed)
- try with resources
- catching multiple exception types and rethrowing exceptions with improved type checking
    

Per Sreenivasa Viswanadha (as posted on the javacc user mailing list), the
original java 1.5 grammar is licensed under the BSD license, so this modified
grammar is also.

Redistribution and use in source and binary forms, with or without modification,
are permitted provided that the following conditions are met:

    * Redistributions of source code must retain the above copyright notice,
    this list of conditions and the following disclaimer.
    * Redistributions in binary form must reproduce the above copyright notice,
    this list of conditions and the following disclaimer in the documentation
    and/or other materials provided with the distribution.
    * Neither the name of the <ORGANIZATION> nor the names of its contributors
    may be used to endorse or promote products derived from this software without
    specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/


options {
  JAVA_UNICODE_ESCAPE = false;
  ERROR_REPORTING = true;
  STATIC = false;
  DEBUG_PARSER = false;
  JDK_VERSION = "15";
}

PARSER_BEGIN(JavaParser)
package parser;
import java.io.*;
import pkgAttribute.*;
import pkgClass.*;
import pkgMethod.*;
import pkgMethodCall.*;
import pkgInterface.*;
import utility.*;
import java.util.ArrayList;
import java.util.List;
import java.util.Scanner;

import static utility.JavaInterpreter.*;

public class JavaParser
{
	private JavaObjetManager objectManager;
	private static List<File> fileList;
    /**
     * Constructor for JavaParser.
     * @param file the file to parse
     */
   public JavaParser(File file, JavaObjetManager objectManager)
   {
      try {
          this.objectManager = objectManager;
          InputStream stream = new FileInputStream(file);
	      jj_input_stream = new SimpleCharStream(stream, 1, 1); 
	      token_source = new JavaParserTokenManager(jj_input_stream);
	      ReInit(stream);
      }
      catch(Exception e) {
        e.printStackTrace();
      }
   }

   public JavaObjetManager getObjectManager() {
		return this.objectManager;
     }


  /*
   * Returns true if the next token is not in the FOLLOW list of "expansion".
   * It is used to decide when the end of an "expansion" has been reached.
   */
  private boolean notTailOfExpansionUnit() {
    Token t;
    t = getToken(1);
    if (t.kind == BIT_OR || t.kind == COMMA || t.kind == RPAREN || t.kind == RBRACE || t.kind == RBRACKET) return false;
    return true;
  }

  // Main method for testing, here is a one-liner bash script that can be ran from
  // the command line:
  // for f in /some/directory/full/of/java/files/*.java; do java -cp . JavaParser $f; done
  public static void main(String[] args) {
    int indice = -1;
    String indiceString = "";
    boolean exit = false;
    boolean pathNull = true;
    boolean resultDisponible = false;
    String pathFile = null;
    if (args.length == 0) {
      while(!exit) {
        do {
	      	System.out.println("\n\n\t\t\t\t\t==================================");
	    	System.out.println("\t\t\t\t\t========  MENU PRINCIPAL  ========");
	    	System.out.println("\t\t\t\t\t==================================");
	        System.out.println("\t 1. Entrer le path du fichier à analyser");
	        System.out.println("\t\t Note: Vous pouvez entrer le path d'un fichier ou le path d'un dossier contenant les fichiers .java");
	        System.out.print("\t 2. Lancer l'analyse ");
	        if(!pathNull)
	        	System.out.println("(ALLOWED)");
	        else
	        	System.out.println("(NOT ALLOWED)");
	        System.out.print("\t 3. Ouvrir le fichier de resultat saved du dossier \"" + directoryResultat + "\"");
	        if(resultDisponible)
	        	System.out.println(" (ALLOWED)");
	        else
	        	System.out.println(" (NOT ALLOWED)");
	        System.out.print("\t 4. Voir tous les resultats sur la console ");
	        if(resultDisponible)
	        	System.out.println(" (ALLOWED)");
	        else
	        	System.out.println(" (NOT ALLOWED)");
	        System.out.println("\t 0. Quitter");
	        System.out.print("Clavier |> ");
	        indiceString = new Scanner(System.in).nextLine();
	      } while(!indiceString.matches("[0-9]"));

	      indice = Integer.parseInt(indiceString);

		  // to exit application
	      if(indice == 0) {
	        	exit = true;
	      }
	      else if(indice == 1) {
				System.out.println("COMPUTER : Veuillez entrer le path des fichiers à analyser (exemple : src/Test)");
				System.out.print("Clavier |> ");
		        pathFile = new Scanner(System.in).nextLine();
		        if(pathFile != null)
					pathNull = false;

				// reinitialiser
				resultDisponible = false;
	        }
	        else if(indice == 2 && !pathNull) {
	          lancerAnalyse(pathFile, false);
	          resultDisponible = true;
	        }
	        else if(indice == 2) { 
	        	System.out.println("COMPUTER : Sorry, le parser n'a aucun fichier à analyser...");
	        	System.out.println("COMPUTER : Veuillez commencer par entrer le path d'un fichier ou dossier !");	        	
	       }
	       else if(indice == 3 && !resultDisponible) { 
	        	System.out.println("COMPUTER : Sorry, Les resultats ne sont pas encore pret");
	        	System.out.println("COMPUTER : Veuillez commencer par lancer l'analyser de l'option 2 ");	        	
	       }
	       else if(indice == 3 & resultDisponible) {
		        int fChoice = -1;
		        String fChoiceString = "";
        System.out.println("\t\tVoici la liste des fichiers contanent le resultat d'analyse");
		        System.out.println("\t\tNote : le format est \"NomClasse-Annee-Mois-Jour_Heure-Minutes-secondes.txt\"");
		        List<File> fileListResultat = JavaFileExplorer.getAllJavaFiles(new File(directoryResultat), 0, ".txt");
	              assert fileListResultat != null;
	              for(int i = 0 ; i < fileListResultat.size(); i++) {
                	System.out.println("\t\t\t" + (i+1) + ". " + fileListResultat.get(i).getName());
	              }
				do { 
					System.out.println("COMPUTER : Veuillez entrer l'indice du fichier");
	                System.out.print("Clavier |> ");
	                fChoiceString = new Scanner(System.in).nextLine();
	              } while(!fChoiceString.matches("[0-9]") || Integer.parseInt(fChoiceString) > fileListResultat.size() || Integer.parseInt(fChoiceString) == 0);
				fChoice = Integer.parseInt(fChoiceString) - 1;
				String nameFile = fileListResultat.get(fChoice).getName();
				List<String> output =  readFile(nameFile);
				System.out.println();
				System.out.println("=========================================================== FILE " + nameFile + " =========================================================");
                for(String line : output) {
                        System.out.println(line);
                   }
                System.out.print("========================================================================================================================================================================");
	         }
	         else if(indice == 4 && resultDisponible) {
				lancerAnalyse(pathFile, true);
	           }
            else if(indice == 4 && !resultDisponible) {
				System.out.println("COMPUTER : Sorry, Les resultats ne sont pas encore pret");
	        	System.out.println("COMPUTER : Veuillez commencer par lancer l'analyser de l'option 2 ");
           	}
        }
    } else if (args.length == 1) {
       lancerAnalyse(args[0], true);
    } else {
      System.out.println("Sorry, nous ne prenons pas en charge ce nombre d'entree !");
    }
  }

/**
* Methode qui permet de lire le fichier, pour retourner toutes les lignes de celle-ci dans une liste
* @param fileName le nom du fichier à lire
* @return List<String>
*/
  private static List<String> readFile(String fileName) {
		String path = directoryResultat + "/" + fileName;

		List<String> lines = new ArrayList<String>();
		try {
			BufferedReader br = new BufferedReader(new FileReader(path));
			String line;
			while((line = br.readLine()) != null) {
					lines.add(line);
			   }
			br.close();
		  }catch (FileNotFoundException e) {
            System.out.println("COMPUTER : Le fichier \""
                    + fileName + "\" est introuvable");
            e.printStackTrace();
        } catch (IOException e) {
            e.printStackTrace();
        }

        return lines;
    }

/**
* Methode qui permet de lancer l'analyse sur le path dont l'utilisateur a entré
* @param path le chemin des fichiers ou dossier à analyser
*/
  private static void lancerAnalyse(String path, boolean allowShowConsole) {
		File file = new File(path);
        fileList = bindingFile(file);
        traitment(fileList, file, allowShowConsole);
    }

/**
* Methode qui permet de trouver tous les fichiers contenus dans le Fichier path fourni par l'Utilisateur
* Si jamais il fourni le path d'un dossier, aller chercher tous les fichiers java pour le sauvergarder
* dans une liste et notre liste ne contiendra qu'un seul élément dans le cas où l'utilisateur entrait
* le path d'un fichier directement.
* @param file le FichierPath contenant les fichiers à analyser
*/
  private static List<File> bindingFile(File file){
	List<File> list = new ArrayList<File>();
	System.out.println("Java Parser Version 1.7:  Reading from file " + file.getName() + "...");

        if(!file.exists()) {
          	System.out.println("Aucune fichier trouvé dans le chemin fourni");
      		System.exit(1);
          }

          // Check if it is a directory or a single file
      	if(!file.isFile()) {
			List<File> javaFiles = JavaFileExplorer.getAllJavaFiles(file, 999, ".java");
			if(javaFiles != null) {
				list.addAll(javaFiles);
				return list;
			}
			else {
				System.out.println("Erreur lors de l'ouverture des dossiers.");
      	  		System.exit(1);
			}
        }
        else {
			// when is a file
			list.add(file);
			return list;
        }

        return null;
	}

/**
* Methode qui permet de passer tous les fichiers recueillies dans la liste dans le parser
* @param fileList la liste contenant tous les fichiers java à analyser
* @param file correspond au fichier ouvert pour traitement
*/
	public static void traitment(List<File> fileList, File file, boolean allowShowConsole){
	    JavaObjetManager om = new JavaObjetManager();
	        JavaParser parser;
	        int error = 0;
	        for(File fs: fileList) {
				try {
					parser = new JavaParser(fs, om);
					parser.getObjectManager().push(new JavaFile(file));
					parser.CompilationUnit();
					System.out.println(String.format("%s: analyse en cours...", fs.getName()));
				}
				catch(ParseException e) {
					error++;
					System.out.println(String.format("%s: Erreur: %s", fs.getName(), e.getMessage()));
				}
	        }
	
			if(error == 0) {
				JavaInterpreter interpreter = new JavaInterpreter(om);
				interpreter.showStatisticToConsole(allowShowConsole);
			}
	}
}





PARSER_END(JavaParser)



/********************************************
 * THE JAVA TOKEN SPECIFICATION STARTS HERE *
 ********************************************/

/* WHITE SPACE */

SKIP :
{
  " "
| "\t"
| "\n"
| "\r"
| "\f"
}

/* COMMENTS */

MORE :
{
  /* danson, added backup(2) for special handling of single line comments at
  the end of a file, see <IN_SINGLE_LINE_COMMENT> special token below */
  "//" { input_stream.backup(2); } : IN_SINGLE_LINE_COMMENT
|
  <"/**" ~["/"]> { input_stream.backup(1); } : IN_FORMAL_COMMENT
|
  "/*" : IN_MULTI_LINE_COMMENT
}

<IN_SINGLE_LINE_COMMENT>
SPECIAL_TOKEN :
{
  /* this is the original, I've replaced with the next line to allow a single
  line comment at the end of a java file without a new line following the
  comment.  The java language specification says that single line comments
  must be followed by an end-of-line marker (see section 3.4), so this new rule
  relaxes that requirement slightly by allowing the line terminator to be
  optional.  This only makes sense when the comment is the last line of the
  source file, all other single line comments will have a line terminator. This
  request was posted as a bug against JBrowse, I don't see any problem with
  allowing it, especially since Sun's compiler doesn't complain. */
  /* <SINGLE_LINE_COMMENT: "\n" | "\r" | "\r\n" > : DEFAULT */
  < SINGLE_LINE_COMMENT: "//"(~["\n","\r"])* ("\n"|"\r"|"\r\n")? > : DEFAULT
}

<IN_FORMAL_COMMENT>
SPECIAL_TOKEN :
{
  <FORMAL_COMMENT: "*/" > : DEFAULT
}

<IN_MULTI_LINE_COMMENT>
SPECIAL_TOKEN :
{
  <MULTI_LINE_COMMENT: "*/" > : DEFAULT
}

<IN_SINGLE_LINE_COMMENT,IN_FORMAL_COMMENT,IN_MULTI_LINE_COMMENT>
MORE :
{
  < ~[] >
}

/* RESERVED WORDS AND LITERALS */

TOKEN :
{
  < ABSTRACT: "abstract" >
| < ASSERT: "assert" >
| < BOOLEAN: "boolean" >
| < BREAK: "break" >
| < BYTE: "byte" >
| < CASE: "case" >
| < CATCH: "catch" >
| < CHAR: "char" >
| < CLASS: "class" >
| < CONST: "const" >
| < CONTINUE: "continue" >
| < _DEFAULT: "default" >
| < DO: "do" >
| < DOUBLE: "double" >
| < ELSE: "else" >
| < ENUM: "enum" >
| < EXTENDS: "extends" >
| < FALSE: "false" >
| < FINAL: "final" >
| < FINALLY: "finally" >
| < FLOAT: "float" >
| < FOR: "for" >
| < GOTO: "goto" >
| < IF: "if" >
| < IMPLEMENTS: "implements" >
| < IMPORT: "import" >
| < INSTANCEOF: "instanceof" >
| < INT: "int" >
| < INTERFACE: "interface" >
| < LONG: "long" >
| < NATIVE: "native" >
| < NEW: "new" >
| < NULL: "null" >
| < PACKAGE: "package">
| < PRIVATE: "private" >
| < PROTECTED: "protected" >
| < PUBLIC: "public" >
| < RETURN: "return" >
| < SHORT: "short" >
| < STATIC: "static" >
| < STRICTFP: "strictfp" >
| < SUPER: "super" >
| < SWITCH: "switch" >
| < SYNCHRONIZED: "synchronized" >
| < THIS: "this" >
| < THROW: "throw" >
| < THROWS: "throws" >
| < TRANSIENT: "transient" >
| < TRUE: "true" >
| < TRY: "try" >
| < VOID: "void" >
| < VOLATILE: "volatile" >
| < WHILE: "while" >
}

/* LITERALS */
// DONE: Java 7 allows a binary literal.
// DONE: Java 7 allows underscores in numeric literals to improve readability, e.g. 
// long creditCardNumber = 1234_5678_9012_3456L;
TOKEN :
{
  < INTEGER_LITERAL:
        <DECIMAL_LITERAL> (["l","L"])?
      | <HEX_LITERAL> (["l","L"])?
      | <BINARY_LITERAL> (["l","L"])?
      | <OCTAL_LITERAL> (["l","L"])?
  >
|
  < #DECIMAL_LITERAL: ["1"-"9"] ((["_"])*["0"-"9"])* >      // Java 7 allows underscores
|
  < #HEX_LITERAL: "0" ["x","X"] (["0"-"9","a"-"f","A"-"F"])((["_"])*["0"-"9","a"-"f","A"-"F"])* >      // Java 7 allows underscores
|
  < #BINARY_LITERAL: "0" ["b","B"] (["0"-"1"])((["_"])*["0"-"1"])* >   // new for Java 7, also allows underscores
|
  < #OCTAL_LITERAL: "0" ((["_"])*(["0"-"7"]))* >      // Java 7 allows underscores
|
  < FLOATING_POINT_LITERAL:
        (["0"-"9"])((["_"])*(["0"-"9"]))* "." ((["0"-"9"])((["_"])*(["0"-"9"]))*)* (<EXPONENT>)? (["f","F","d","D"])?
      | "." (["0"-"9"])((["_"])*(["0"-"9"]))* (<EXPONENT>)? (["f","F","d","D"])?
      | (["0"-"9"])((["_"])*(["0"-"9"]))* <EXPONENT> (["f","F","d","D"])?
      | (["0"-"9"])((["_"])*(["0"-"9"]))* (<EXPONENT>)? ["f","F","d","D"]
  >
  
|
  < #EXPONENT: ["e","E"] (["+","-"])? (["0"-"9"])+ >
|
  < CHARACTER_LITERAL:
      "'"
      (   (~["'","\\","\n","\r"])
        | ("\\"
            ( ["n","t","b","r","f","\\","'","\""]
            | ["0"-"7"] ( ["0"-"7"] )?
            | ["0"-"3"] ["0"-"7"] ["0"-"7"]
            )
          )
      )
      "'"
  >
|
  < STRING_LITERAL:
      "\""
      (   (~["\"","\\","\n","\r"])
        | ("\\"
            ( ["n","t","b","r","f","\\","'","\""]
            | ["0"-"7"] ( ["0"-"7"] )?
            | ["0"-"3"] ["0"-"7"] ["0"-"7"]
            )
          )
      )*
      "\""
  >
}

/* IDENTIFIERS */

TOKEN :
{
  < IDENTIFIER: <LETTER> (<LETTER>|<DIGIT>)* >
|
  < #LETTER:
      [
       "\u0024",
       "\u0041"-"\u005a",
       "\u005f",
       "\u0061"-"\u007a",
       "\u00c0"-"\u00d6",
       "\u00d8"-"\u00f6",
       "\u00f8"-"\u00ff",
       "\u0100"-"\u1fff",
       "\u3040"-"\u318f",
       "\u3300"-"\u337f",
       "\u3400"-"\u3d2d",
       "\u4e00"-"\u9fff",
       "\uf900"-"\ufaff"
      ]
  >
|
  < #DIGIT:
      [
       "\u0030"-"\u0039",
       "\u0660"-"\u0669",
       "\u06f0"-"\u06f9",
       "\u0966"-"\u096f",
       "\u09e6"-"\u09ef",
       "\u0a66"-"\u0a6f",
       "\u0ae6"-"\u0aef",
       "\u0b66"-"\u0b6f",
       "\u0be7"-"\u0bef",
       "\u0c66"-"\u0c6f",
       "\u0ce6"-"\u0cef",
       "\u0d66"-"\u0d6f",
       "\u0e50"-"\u0e59",
       "\u0ed0"-"\u0ed9",
       "\u1040"-"\u1049"
      ]
  >
}

/* SEPARATORS */

TOKEN :
{
  < LPAREN: "(" >
| < RPAREN: ")" >
| < LBRACE: "{" >
| < RBRACE: "}" >
| < LBRACKET: "[" >
| < RBRACKET: "]" >
| < SEMICOLON: ";" >
| < COMMA: "," >
| < DOT: "." >
| < AT: "@" >
}

/* OPERATORS */

TOKEN :
{
  < ASSIGN: "=" >
| < LT: "<" >
| < BANG: "!" >
| < TILDE: "~" >
| < HOOK: "?" >
| < COLON: ":" >
| < EQ: "==" >
| < LE: "<=" >
| < GE: ">=" >
| < NE: "!=" >
| < SC_OR: "||" >
| < SC_AND: "&&" >
| < INCR: "++" >
| < DECR: "--" >
| < PLUS: "+" >
| < MINUS: "-" >
| < STAR: "*" >
| < SLASH: "/" >
| < BIT_AND: "&" >
| < BIT_OR: "|" >
| < XOR: "^" >
| < REM: "%" >
| < LSHIFT: "<<" >
| < PLUSASSIGN: "+=" >
| < MINUSASSIGN: "-=" >
| < STARASSIGN: "*=" >
| < SLASHASSIGN: "/=" >
| < ANDASSIGN: "&=" >
| < ORASSIGN: "|=" >
| < XORASSIGN: "^=" >
| < REMASSIGN: "%=" >
| < LSHIFTASSIGN: "<<=" >
| < RSIGNEDSHIFTASSIGN: ">>=" >
| < RUNSIGNEDSHIFTASSIGN: ">>>=" >
| < ELLIPSIS: "..." >
| < POINTER: "->" >
| < DIAMOND: "<>" >

}

/* >'s need special attention due to generics syntax. */
TOKEN :
{
  < RUNSIGNEDSHIFT: ">>>" >
  {
     matchedToken.kind = GT;
     ((Token.GTToken)matchedToken).realKind = RUNSIGNEDSHIFT;
     input_stream.backup(2);
  }
| < RSIGNEDSHIFT: ">>" >
  {
     matchedToken.kind = GT;
     ((Token.GTToken)matchedToken).realKind = RSIGNEDSHIFT;
     input_stream.backup(1);
  }
| < GT: ">" >
}





/*****************************************
 * THE JAVA LANGUAGE GRAMMAR STARTS HERE *
 *****************************************/

/**
 * Main entry point for parsing java files.
 */
void CompilationUnit():
{
  JavaFile currentFile = (JavaFile) objectManager.peek();
  String buffer = "";
}
{
  [ LOOKAHEAD( ( Annotation() )* "package" ) buffer = PackageDeclaration() ]
  {
    currentFile.setPkg(buffer);
  }
  ( buffer = ImportDeclaration()
  {
    currentFile.addImport(new JavaImport(buffer));
  })*
  ( TypeDeclaration() )+
  ( < "\u001a" > )?
  ( <STUFF_TO_IGNORE: ~[]> )? 
  <EOF>
}

/**
* Récuperation du nom de package
* @return String
*/
String PackageDeclaration():
{
  String name = "";
}
{
  Modifiers() "package" name = Name() ";"
  {
    return name;
  }
}


/**
* Récuperation des declarations importées
* @return String
*/
String ImportDeclaration():
{
  String name = "";
}
{
  "import" [ "static" ] name = Name() [ "." "*" { name += ".*"; } ] ";"
  {
	return name;
  }
}

/**
* Récuperation de la portée sous forme d'entier
* @return int
*/
int Modifiers():
{
   int modifiers = 0;
}
{
 (
  LOOKAHEAD(2)
  (
   "public" { modifiers |= JavaModifierSet.PUBLIC; }
  |
   "static" { modifiers |= JavaModifierSet.STATIC; }
  |
   "protected" { modifiers |= JavaModifierSet.PROTECTED; }
  |
   "private" { modifiers |= JavaModifierSet.PRIVATE; }
  |
   "final" { modifiers |= JavaModifierSet.FINAL; }
  |
   "abstract" { modifiers |= JavaModifierSet.ABSTRACT; }
  |
   "synchronized" { modifiers |= JavaModifierSet.SYNCHRONIZED; }
  |
   "native" { modifiers |= JavaModifierSet.NATIVE; }
  |
   "transient" { modifiers |= JavaModifierSet.TRANSIENT; }
  |
   "volatile" { modifiers |= JavaModifierSet.VOLATILE; }
  |
   "strictfp" { modifiers |= JavaModifierSet.STRICTFP; }
  |
   Annotation()
  )
 )*

 {
    return modifiers;
 }
}


/*
 * Suivre la porté des classes, interfaces
 */

// Handle classes, interfaces, enums, and annotations.
void TypeDeclaration():
{
  int modifiers;
}
{
          ";"
        |
         modifiers = Modifiers()
          (
              LOOKAHEAD(2)
             ClassOrInterfaceDeclaration(modifiers)
           | 
             EnumDeclaration(modifiers)
           | 
             AnnotationTypeDeclaration(modifiers)
          )
}

/**
* Pour chaque classe et interface, faire suivre la porté @code{modifiers}
*/
void ClassOrInterfaceDeclaration(int modifiers):
{	
   	boolean isInterface = false;
   	Token nameToken;
   	List<String> extendsList = new ArrayList<String>();
   	List<String> implementsList = new ArrayList<String>();
}
{
  ( "class" | "interface" { isInterface = true; } )
  nameToken = <IDENTIFIER>
  [ TypeParameters() ]
  [ extendsList = ExtendsList(isInterface) ]
  [ implementsList = ImplementsList(isInterface) ]

  {
    if(isInterface)
    {
      //NOTE: We are in an interface, there's no implements
      // but extendsList might contain multiple values
      JavaInterface i = new JavaInterface(nameToken.toString());
	  i.setiScope(modifiers);
	  //NOTE: We add each interface it inherits from	
       for (String s : extendsList) {
                 i.addInterface(new JavaInterface(s));
       }
      //NOTE: Pass to the object manager
      objectManager.addToCurrentObject(i);
    }
    else
    {
      //NOTE: We are in a class, limited to extendsList(0) unless its null
      JavaClass c = new JavaClass(nameToken.toString());
      c.setcScope(modifiers);
      if(extendsList.size() > 0)
      {
        c.setSuperClass(extendsList.get(0));
      }
	  //NOTE: We add each interface	
      for (String s : implementsList) {
        c.addInterface(new JavaInterface(s));
      }
      //NOTE: Pass to the object manager
      objectManager.addToCurrentObject(c);
    }
  }

  ClassOrInterfaceBody(isInterface)

  //NOTE: We're not inside a class or an interface anymore
  {
    objectManager.pop();
  }
}

/**
* Récuperation la liste des extends, considérer que la classe ne peut pas extends plus d'une classe
* @return List<String>
*/
List<String> ExtendsList(boolean isInterface):
{
   List<String> extendsList = new ArrayList<String>();
   String currentExtent = "";
   boolean extendsMoreThanOne = false;
}
{
   "extends" currentExtent = ClassOrInterfaceType()
   {
     extendsList.add(currentExtent);
   }
   ( "," currentExtent = ClassOrInterfaceType()
   {
     extendsMoreThanOne = true;
   	 extendsList.add(currentExtent);
   } )*
   {
      if (extendsMoreThanOne && !isInterface)
         throw new ParseException("A class cannot extend more than one other class");

      return extendsList;
   }
}

/**
* Récuperation la liste des implementations, considérer qu'une interface ne peut pas implementer une autre interface
* @return List<String>
*/
List<String> ImplementsList(boolean isInterface):
{
	List<String> implementsList = new ArrayList<String>();
   	String currentImplement = "";
}
{
   "implements" currentImplement = ClassOrInterfaceType()
   {
     implementsList.add(currentImplement);
   }
   ( "," currentImplement = ClassOrInterfaceType()
   {
     implementsList.add(currentImplement);
   } )*
   {
      if (isInterface) { 
         throw new ParseException("An interface cannot implement other interfaces");
	}
      return implementsList;
   }
}

/**
* Savoir qu'une Enumération ne peut implementer quoique ce soit  @see { false }
*/
void EnumDeclaration(int modifiers):
{
}
{
        "enum" <IDENTIFIER>
        [ ImplementsList(false) ]
        EnumBody()

}

/**
* Savoir que une Enumération n'est pas contenir une classe ou une interface @see { false }
*/
void EnumBody():
{
}
{
        "{"
        EnumConstant() ( LOOKAHEAD(2) "," EnumConstant() )* [","]
        [ ";" ( ClassOrInterfaceBodyDeclaration(false) )* ]
        "}"
}

/**
* Savoir que les constantes d'une énumérations ne peuvent contenir une classe ou une interface @see { false }
*/
void EnumConstant():
{
}
{
        <IDENTIFIER> [ Arguments() ] [ ClassOrInterfaceBody(false) ]
}

void TypeParameters():
{
}
{
        (
            "<"
            (
            TypeParameter()
            )?
            (
                ","
                TypeParameter()
            )*
            ">"
        )
}

void TypeParameter():
{
}
{
        (
            <IDENTIFIER> [ TypeBound() ]
        )

}

void TypeBound():
{
}
{
        (
            "extends"
            ClassOrInterfaceType()
            (
                "&"
                ClassOrInterfaceType()
            )*
        )
}

// le corps d'une classe ou interface
void ClassOrInterfaceBody(boolean isInterface):
{
}
{
        (
            "{"
            (
                ClassOrInterfaceBodyDeclaration(isInterface)
            )*
            "}"
        )
}

void ClassOrInterfaceBodyDeclaration(boolean isInterface):
{
   boolean isNestedInterface = false;
   int modifiers;
}
{
  LOOKAHEAD(2)
  Initializer()
  {
     if (isInterface)
        throw new ParseException("An interface cannot have initializers");
  }
|
  modifiers = Modifiers() // Just get all the modifiers out of the way. If you want to do
              // more checks, pass the modifiers down to the member
  (
      ClassOrInterfaceDeclaration(modifiers)
    |
      EnumDeclaration(modifiers)
    |
      LOOKAHEAD( [ TypeParameters() ] <IDENTIFIER> "(" )
      ConstructorDeclaration(modifiers)
    |
      LOOKAHEAD( Type() <IDENTIFIER> ( "[" "]" )* ( "," | "=" | ";" ) )
      FieldDeclaration(modifiers)
    |
      MethodDeclaration(modifiers)
    |
      AnnotationTypeDeclaration(modifiers)
  )
|
  ";"
}

/**
* initialiser le nom et type des champs tout en faisant suivre la portée
*/
void FieldDeclaration(int modifiers):
{
  JavaAttribute a = new JavaAttribute();
  a.setaScope(modifiers);
  String type = "";
  String name = "";
}
{
  // Modifiers are already matched in the caller
  type = Type() name = VariableDeclarator()
  {
    a.setaName(name);
    a.setaType(type);
    objectManager.addToCurrentObject(a);
  }
   ( "," VariableDeclarator()
   {
      //NOTE(): Type and modifiers are already defined		
      a.setaName(name);
      objectManager.addToCurrentObject(a);
   }
    )* ";"
}

/**
* Récuperation du nom de la variable declarée
* @return String
*/
String VariableDeclarator():
{
  String name = "";
}
{
  name = VariableDeclaratorId() [ "=" VariableInitializer() ]
  {
    return name;
  }
}

/**
* Récuperation de l'identifiacteur de la variable declarée
* @return String
*/
String VariableDeclaratorId():
{
	Token nameToken;
}
{
  nameToken = <IDENTIFIER> ( "[" "]" )*
  {
    return nameToken.toString();
  }
}


void VariableInitializer():
{
}
{
          ArrayInitializer()
        |
          Expression()
}


void ArrayInitializer():
{
}
{
        "{" [ VariableInitializer() ( LOOKAHEAD(2) "," VariableInitializer() )* ] [ "," ] "}"

}

/**
* Récuperation des informations de la methode declarée, ainsi que initilisé son type et faire suivre la portée
* 
*/
void MethodDeclaration(int modifiers):
{
  JavaMethod m;
  String returnType = "";
}
{
  // Modifiers already matched in the caller!
  [ TypeParameters() ]
  returnType = ResultType()
  m = MethodDeclarator() [ "throws" NameList() ]
  {
    m.setmTypeReturn(returnType);
    objectManager.addToCurrentObject(m);
  }
  //NOTE: We're about to enter the method body, method is on top of stack
  ( Block()
  //NOTE: We left the method body, so let's pop the method out
  {
    objectManager.pop();
  }
  | ";" )
}

/**
* Création d'un objet JavaMethod et la récupération de tous ses paramètres
* @return JavaMethod
*/
JavaMethod MethodDeclarator():
{
	Token nameToken;
	List<JavaAttribute> parameters;
}
{
  nameToken = <IDENTIFIER> parameters = FormalParameters() ( "[" "]" )*

  {
    JavaMethod m = new JavaMethod(nameToken.toString());
    m.addParameters(parameters);
    return m;
  }
}

/**
* Récuperation la liste des attributes sous la forme de notre objet "JavaAttribute"
* @return List<JavaAttribute>
*/
List<JavaAttribute> FormalParameters():
{
	List<JavaAttribute> parameters = new ArrayList<JavaAttribute>();
	JavaAttribute buffer;
}
{
  "(" [ buffer = FormalParameter()
  {
    parameters.add(buffer);
  }
   ( "," buffer = FormalParameter()
   {
     parameters.add(buffer);
   }
    )* ] ")"

  {
    return parameters;
  }	  
}

/**
* Création et initialisation d'un objet JavaAttribute
* @return JavaAttribute
*/
JavaAttribute FormalParameter():
{
	int modifiers;
	String type = "";
	String name = "";
}
{
  // danson, added
  //          [ "final" | Annotation() ]
  // See Java Language Specification, 3rd Edition, section 8.4.1
  modifiers = Modifiers() [ "final" | Annotation() ] type = Type() [ "..." ] name = VariableDeclaratorId()
  {
    return new JavaAttribute(name, type, modifiers);
  }
}

/**
* initialisation du constructeur, tout en faisant suivrant la portée
*
*/
void ConstructorDeclaration(int modifiers):
{
	List<JavaAttribute> parameters;
	Token nameToken;
}
{
  [ TypeParameters() ]
  // Modifiers matched in the caller
  nameToken = <IDENTIFIER> parameters = FormalParameters() [ "throws" NameList() ]
  "{"
    [ LOOKAHEAD(ExplicitConstructorInvocation())
         ExplicitConstructorInvocation()
    ]
    {
      JavaMethod m = new JavaMethod(nameToken.toString());
      m.addParameters(parameters);
      m.setmScope(modifiers);
      objectManager.addToCurrentObject(m);
    }
    //NOTE: We're entering the constructor body, it is on top of stack
    ( BlockStatement() )*
    //NOTE: We're exiting the constructor body, lets pop out the method
    {
      objectManager.pop();
    }
  "}"
}


void ExplicitConstructorInvocation():
{}
{
  ( <IDENTIFIER> "." )* [ LOOKAHEAD(2) "this" "." ]
  [ TypeArguments() ] ("this"|"super") Arguments() ";"
}


void Initializer():
{
}
{
        [ <STATIC> ] Block()
}

/**
* Récuperation du Type Simple
* @return String
*/
String Type():
{
  String name = "";
}
{
   (
     LOOKAHEAD(2) name = ReferenceType()
 |
   name = PrimitiveType()
   )
   {
     return name;
   }
}

/**
* Récuperation du Type reference
* @return String
*/
String ReferenceType():
{
  String name = "";
}
{
   (
     name = PrimitiveType() ( LOOKAHEAD(2) "[" "]" )+
  |
   ( name = ClassOrInterfaceType() ) ( LOOKAHEAD(2) "[" "]" )*)

   {
     return name;
   }
}

/**
* Récuperation du Type de la classe ou interface
* @return String
*/
String ClassOrInterfaceType():
{
  Token nameToken;
}
{
  nameToken = <IDENTIFIER> [ LOOKAHEAD(2) TypeArguments() ]
  ( LOOKAHEAD(2) "." <IDENTIFIER> [ LOOKAHEAD(2) TypeArguments() ] )*
  {
    return nameToken.toString();
  }
}


void TypeArguments():
{
}
{
        (
         <DIAMOND>   
        )
        |
        (
        "<" TypeArgument() 

        ( "," TypeArgument() )* ">"
        )
}

void TypeArgument():
{
}
{
        (
           ReferenceType()
         |
         "?" [ WildcardBounds() ]
        )
}

void WildcardBounds():
{
}
{
        (
        "extends" ReferenceType()
     |
        "super" ReferenceType() 
        )
}

/**
* Récuperation du nom de type Simple
* @return String
*/
String PrimitiveType():
{
  Token nameToken;
}
{
  (
    nameToken = "boolean"
|
  nameToken = "char"
|
  nameToken = "byte"
|
  nameToken = "short"
|
  nameToken = "int"
|
  nameToken = "long"
|
  nameToken = "float"
|
  nameToken = "double")

  {
    return nameToken.toString();
  }
}

/**
* Récuperation du Type de Resultat sinon void
* @return String
*/
String ResultType():
{
	Token nameToken;
	String name = "";
}
{
  nameToken = "void"
  {
    return nameToken.toString();
  }
|
  name = Type()
  {
    return name;
  }
}


String Name():
/*
 * A lookahead of 2 is required below since "Name" can be followed
 * by a ".*" when used in the context of an "ImportDeclaration".
 */
{
  Token nameToken;
  String buffer = "";
}
{
  nameToken = <IDENTIFIER>
  {
    buffer = nameToken.toString();
  }
  ( LOOKAHEAD(2) "." nameToken = <IDENTIFIER>
  {
    buffer += "." + nameToken.toString();
  }
  )*

  {
    return buffer;
  }
}


void NameList():
{
}
{
    
        Name() 
        ( "," Name() )*   
}


/*
 * Expression syntax follows.
 */

void Expression():
/*
 * This expansion has been written this way instead of:
 *   Assignment() | ConditionalExpression()
 * for performance reasons.
 * However, it is a weakening of the grammar for it allows the LHS of
 * assignments to be any conditional expression whereas it can only be
 * a primary expression.  Consider adding a semantic predicate to work
 * around this.
 */
{
}
{
    
          ConditionalExpression()
          [
            LOOKAHEAD(2)
            AssignmentOperator() Expression()
          ]
}

void AssignmentOperator():
{}
{
  "=" | "*=" | "/=" | "%=" | "+=" | "-=" | "<<=" | ">>=" | ">>>=" | "&=" | "^=" | "|="
}

void ConditionalExpression():
{
}
{
    
        ConditionalOrExpression() [ "?" Expression() ":" Expression() ]
}

void ConditionalOrExpression():
{
}
{
    
        ConditionalAndExpression() ( "||" ConditionalAndExpression() )*
}

void ConditionalAndExpression():
{
}
{
    
        InclusiveOrExpression() ( "&&" InclusiveOrExpression() )*
}

void InclusiveOrExpression():
{
}
{
    
        ExclusiveOrExpression() ( "|" ExclusiveOrExpression() )*
}

void ExclusiveOrExpression():
{
}
{
    
        AndExpression() ( "^" AndExpression() )*
}

void AndExpression():
{
}
{
    
        EqualityExpression() ( "&" EqualityExpression() )*
}

void EqualityExpression():
{
}
{
    
        InstanceOfExpression() ( ( "==" | "!=" ) InstanceOfExpression() )*
}

void InstanceOfExpression():
{
}
{
    
        RelationalExpression() [ "instanceof" Type() ]
}

void RelationalExpression():
{
}
{
    
        ShiftExpression() ( ( "<" | ">" | "<=" | ">=" ) ShiftExpression() )*
}

void ShiftExpression():
{
}
{
    
        AdditiveExpression() ( ( "<<" | RSIGNEDSHIFT() | RUNSIGNEDSHIFT() ) AdditiveExpression() )*
}

void AdditiveExpression():
{
}
{
    
        MultiplicativeExpression() ( ( "+" | "-" ) MultiplicativeExpression() )*
}

void MultiplicativeExpression():
{
}
{
    
        UnaryExpression() ( ( "*" | "/" | "%" ) UnaryExpression() )*
}

void UnaryExpression():
{
}
{
    
          ( "+" | "-" ) UnaryExpression()
        |
          PreIncrementExpression()
        | 
          PreDecrementExpression()
        | 
          UnaryExpressionNotPlusMinus()
}

void PreIncrementExpression():
{
}
{
    
        "++" PrimaryExpression()
}

void PreDecrementExpression():
{
}
{
    
        "--" PrimaryExpression()
}

void UnaryExpressionNotPlusMinus():
{
}
{
    
          ( "~" | "!" ) UnaryExpression()
        |
          LOOKAHEAD( CastLookahead() )
          CastExpression()
        |
          PostfixExpression()
}

// This production is to determine lookahead only.  The LOOKAHEAD specifications
// below are not used, but they are there just to indicate that we know about
// this.
void CastLookahead():
{
}
{
    
          LOOKAHEAD(2)
          "(" PrimitiveType()
        |
          LOOKAHEAD("(" Type() "[")
          "(" Type() "[" "]"
        |
          "(" Type() ")" ( "~" | "!" | "(" | <IDENTIFIER> | "this" | "super" | "new" | Literal() )
}

void PostfixExpression():
{
}
{
    
        PrimaryExpression() [ "++" | "--" ]
}

void CastExpression():
{
}
{
    
          LOOKAHEAD("(" PrimitiveType())
          "(" Type() ")" UnaryExpression()
        |
          "(" Type() ")" UnaryExpressionNotPlusMinus()
}

/**
 * JLS 15.8 Primary Expressions
 * Primary expressions include most of the simplest kinds of expressions, from
 * which all others are constructed: literals, class literals, field accesses,
 * method invocations, and array accesses. A parenthesized expression is also
 * treated syntactically as a primary expression.
 */
void PrimaryExpression():
{
	String method = "";
	String buffer = "";
}
{
  method = PrimaryPrefix() ( LOOKAHEAD(2)  buffer = PrimarySuffix()
  {
      method += buffer;
  } )*
  {
    if(method.split("[\\.]").length > 1)
    {
      objectManager.addToCurrentObject(new JavaMethodCall(method));
    }
  }
}

void MemberSelector():
{
}
{
    
        "." TypeArguments() <IDENTIFIER>
}

String PrimaryPrefix():
{
  	String nameToken = null;
	String name = "";
}
{(
  Literal()
|
  LOOKAHEAD( ( <IDENTIFIER> "." )* "this" )
  ( <IDENTIFIER> "." )*
  "this"
|
  "super" "." <IDENTIFIER>
|
   // danson, added this part to support a construct like:
   //   Buffer.super.setDirty(true);
   // See Java Language Specification, 3rd edition, section 15.11.2.
   LOOKAHEAD( ClassOrInterfaceType() "." "super" "." <IDENTIFIER> )
   ClassOrInterfaceType() "." "super" "." <IDENTIFIER>
|
  "(" Expression() ")"
|
  AllocationExpression()
|
  LOOKAHEAD( ResultType() "." "class" )
  ResultType() "." "class"
|
  name = Name())
  {
    return name;
  }
}


String PrimarySuffix():
{
	Token nameToken = null;
}
{
  (
    LOOKAHEAD("." "super" ".")
  "." "super"
|
  LOOKAHEAD("." "this")
  "." "this"
|
  LOOKAHEAD(2)
  "." AllocationExpression()
|
  LOOKAHEAD(3)
  MemberSelector()
|
  "[" Expression() "]"
|
  "." nameToken = <IDENTIFIER>
|
  Arguments()
  {
    return "()";
  })

  {
    return nameToken == null ? "" : String.format(".%s", nameToken.toString());
  }
}


void Literal():
{}
{
    
          <INTEGER_LITERAL>
        |
          <FLOATING_POINT_LITERAL>
        |
          <CHARACTER_LITERAL>
        |
          <STRING_LITERAL>
        |
          BooleanLiteral()
        |
          NullLiteral()
}

void BooleanLiteral():
{}
{
  "true"
|
  "false"
}

void NullLiteral():
{}
{
  "null"
}

void Arguments():
{
}
{
    
        "(" [ ArgumentList() ] ")"
}

void ArgumentList():
{
}
{
    
        Expression() ( "," Expression() )*
}

void AllocationExpression():
{
}
{
    
          LOOKAHEAD(2)
          "new" PrimitiveType() ArrayDimsAndInits() 
        |
          "new" ClassOrInterfaceType() [ TypeArguments() ]
            (
                ArrayDimsAndInits() 
            |
                Arguments() [ ClassOrInterfaceBody(false) ]
            )
}

/*
 * The third LOOKAHEAD specification below is to parse to PrimarySuffix
 * if there is an expression between the "[...]".
 */
void ArrayDimsAndInits():
{
}
{
    
          LOOKAHEAD(2)
          ( LOOKAHEAD(2) "["  Expression() "]" )+ ( LOOKAHEAD(2) "[" "]" )*
        |
          ( "[" "]" )+ ArrayInitializer()
}


/*
 * Statement syntax follows.
 */

void Statement():
{
}
{
    
          (
          LOOKAHEAD(2)
          LabeledStatement()
        |
          AssertStatement()
        |
          Block()
        |
          EmptyStatement()
        |
          StatementExpression() ";"
        |
          SwitchStatement()
        |
          IfStatement()
        |
          WhileStatement()
        |
          DoStatement()
        |
          ForStatement()
        |
          BreakStatement()
        |
          ContinueStatement()
        |
          ReturnStatement()
        |
          ThrowStatement()
        |
          SynchronizedStatement()
        |
          TryStatement()
          )

}

void AssertStatement():
{}
{
    
        "assert" Expression() [ ":" Expression() ] ";"
}

void LabeledStatement():
{}
{
    
        <IDENTIFIER> ":" Statement()
}

void Block():
{
}
{
    
        "{" ( BlockStatement() )* "}"
}

void BlockStatement():
{
}
{
    
        [LOOKAHEAD(2) Annotation()]
            (
          LOOKAHEAD( Modifiers() Type() <IDENTIFIER>)
          LocalVariableDeclaration() ";"
        |
          LOOKAHEAD(3)
          Statement()
        |
          ClassOrInterfaceDeclaration(0)
             )
}

/**
* Récuperation de varaible Locale
*/
void LocalVariableDeclaration():
{
	int modifiers;
	String type;
	String name;
}
{
  modifiers = Modifiers() type = Type() name = VariableDeclarator()
  {
    objectManager.addToCurrentObject(new JavaAttribute(name, type, modifiers));
  }
  ( "," name = VariableDeclarator()
  {
    objectManager.addToCurrentObject(new JavaAttribute(name, type, modifiers));
  } )*
}


void EmptyStatement():
{}
{
  ";"
}

void StatementExpression():
/*
 * The last expansion of this production accepts more than the legal
 * Java expansions for StatementExpression.  This expansion does not
 * use PostfixExpression for performance reasons.
 */
{
}
{
    
          PreIncrementExpression()
        |
          PreDecrementExpression()
        |
          PrimaryExpression()
          [
            "++"
          |
            "--"
          |
            AssignmentOperator() Expression()
          ]
}

void SwitchStatement():
{
}
{
    
        "switch" "(" Expression() ")" "{"
            ( SwitchLabel() ( BlockStatement() )* )*
      "}"

}

void SwitchLabel():
{
}
{
    
          "case" Expression() ":"
        |
          "default" ":"
}

void IfStatement():
/*
 * The disambiguating algorithm of JavaCC automatically binds dangling
 * else's to the innermost if statement.  The LOOKAHEAD specification
 * is to tell JavaCC that we know what we are doing.
 */
{
}
{
    
        "if" "(" Expression() ")" Statement() [ LOOKAHEAD(1) "else" Statement() ]

}

void WhileStatement():
{
}
{
    
        "while" "(" Expression() ")" Statement()
}

void DoStatement():
{
}
{
    
        "do" Statement() "while" "(" Expression() ")" ";"

}

void ForStatement():
{
}
{
    
      "for" "("

      (
          LOOKAHEAD([Annotation()]["final"] Type() <IDENTIFIER> ":")
          [LOOKAHEAD(2) Annotation()]["final"] Type() <IDENTIFIER> ":" Expression()
        |
         [ ForInit() ] ";" [ Expression() ] ";" [ ForUpdate() ]
      )

      ")" Statement()

}

// TODO: what is this? It doesn't appear to be called from anywhere. It's in the
// JLS, but not used, rather, all modifiers are captured in the Modifiers production.
void VariableModifier() :
{}
{
    [LOOKAHEAD(2) Annotation()] ["final"]   
}

void ForInit():
{
}
{
    
          LOOKAHEAD( [ "final" ] Type() <IDENTIFIER> )
          LocalVariableDeclaration() 
        |
        StatementExpressionList() 
}

void StatementExpressionList():
{
}
{
    
        StatementExpression() ( "," StatementExpression() )*
}

void ForUpdate():
{}
{
    
        StatementExpressionList()
}

void BreakStatement():
{}
{
  "break" [ <IDENTIFIER> ] ";"
}

void ContinueStatement():
{}
{
  "continue" [ <IDENTIFIER> ] ";"
}

void ReturnStatement():
{
}
{
    
        "return" [ Expression() ] ";"
}

void ThrowStatement():
{
}
{
    
        "throw" Expression() ";"
}

void SynchronizedStatement():
{
}
{
    
        <SYNCHRONIZED> "(" Expression() ")" Block()

}

void TryStatement():
/*
 * Semantic check required here to make sure that at least one
 * finally/catch is present.
 */
 // DONE: Java 7 allows try with resources, where the resource implements Closeable.
 // e.g.
 // try (BufferedReader br = new BufferedReader(new FileReader(path))) {
 //   return br.readLine();
 // }
 // Note that neither 'catch' nor 'finally' are required in this case.
 //
 // DONE: Java 7 allows 'catch' to handle more than one exception type, e.g.
 // catch (IOException|SQLException ex)
{
}
{
    
        "try" ["(" LocalVariableDeclaration()(LOOKAHEAD(2) ";" LocalVariableDeclaration())* [";"] ")"]
        Block() 
        ( "catch" "(" 
                        (
                            LOOKAHEAD(3)
                            FormalParameter() 
                            |
                            ClassOrInterfaceType()(LOOKAHEAD(2) "|" ClassOrInterfaceType())+ VariableDeclaratorId()
                        )
                  ")" 
            Block()
        )*
        
        [ "finally" 
            Block()
        ]
}

/* We use productions to match >>>, >> and > so that we can keep the
 * type declaration syntax with generics clean
 */

void RUNSIGNEDSHIFT():
{}
{
  ( LOOKAHEAD({ getToken(1).kind == GT &&
                 getToken(1) instanceof Token.GTToken &&
                ((Token.GTToken)getToken(1)).realKind == RUNSIGNEDSHIFT} )
   ">" ">" ">"
  )
}

void RSIGNEDSHIFT():
{}
{
  ( LOOKAHEAD({ getToken(1).kind == GT &&
                 getToken(1) instanceof Token.GTToken &&
                ((Token.GTToken)getToken(1)).realKind == RSIGNEDSHIFT} )
  ">" ">"
  )
}

/* Annotation syntax follows. */

void Annotation():
{
}
{
    
   LOOKAHEAD( "@" Name() "(" ( <IDENTIFIER> "=" | ")" ))
   NormalAnnotation()
 |
   LOOKAHEAD( "@" Name() "(" )
   SingleMemberAnnotation()
 |
   MarkerAnnotation()
}

void NormalAnnotation():
{
}
{
    
        "@" Name() "(" [ MemberValuePairs() ] ")"
}

void MarkerAnnotation():
{
}
{
    
        "@" Name()
}

void SingleMemberAnnotation():
{
}
{
    
        "@" Name() "(" MemberValue() ")"
}

void MemberValuePairs():
{
}
{
    
    MemberValuePair() ( "," MemberValuePair() )*
}

void MemberValuePair():
{
}
{
    
    <IDENTIFIER> "=" MemberValue()
}

void MemberValue():
{
}
{
    
           LOOKAHEAD(2)
           Annotation()      
         |
           MemberValueArrayInitializer()
         |
           ConditionalExpression()
}

void  MemberValueArrayInitializer():
{
}
{
    
    "{" (MemberValue() ( LOOKAHEAD(2) "," MemberValue() )* [ "," ])? "}"
}


/* Annotation Types. */

void AnnotationTypeDeclaration(int modifiers):
{
}
{
    
        "@" "interface" <IDENTIFIER> AnnotationTypeBody()
}

void AnnotationTypeBody():
{
}
{
    
    "{" ( AnnotationTypeMemberDeclaration() )* "}"
}

void AnnotationTypeMemberDeclaration():
{
  int modifiers;
}
{
	modifiers = Modifiers()
 
     (
         LOOKAHEAD(Type() <IDENTIFIER> "(")
         Type() <IDENTIFIER> "(" ")" [ DefaultValue() ] ";" 
         |
         LOOKAHEAD(3)
         ClassOrInterfaceDeclaration(modifiers)
         |
         EnumDeclaration(modifiers)
         |
         LOOKAHEAD(2)
         AnnotationTypeDeclaration(modifiers)
         |
         FieldDeclaration(modifiers)
     )
     |
     ( ";" )
}

void DefaultValue():
{
}
{
        "default" MemberValue()
}

